#!/bin/bash
#
# /etc/rc.d/rc.sysinit - run once at boot time
#
# Taken in part from Miquel van Smoorenburg's bcheckrc.
#

if [ ! -e /proc/mounts ]; then 
	mount -n -t proc /proc /proc
	mount -n -t sysfs /sys /sys >/dev/null 2>&1
fi

# start readahead before anything else
[ -x /sbin/sreadahead ] && /sbin/sreadahead >/dev/null 2>&1

. /etc/init.d/functions

cmdline=$(cat /proc/cmdline)
if strstr "$cmdline" quiet ; then
	quiet="yes"
fi
if strstr "$cmdline" nosplash ; then
	nosplash="yes"
fi

if [ -e /sys/devices/virtual/graphics/fbcon/cursor_blink ]; then
    echo 0 > /sys/devices/virtual/graphics/fbcon/cursor_blink
fi

if [ -z "$nosplash" ]; then
    [ -x /usr/bin/chvt ] && /usr/bin/chvt 2
    [ -x /usr/bin/ply-image ] && /usr/bin/ply-image
fi

HOSTNAME=`/bin/hostname`
HOSTTYPE=`uname -m`

# enable job control
set -m


if [ -z "$HOSTNAME" -o "$HOSTNAME" = "(none)" ]; then
	HOSTNAME=localhost
fi

if [ -f /etc/sysconfig/network ]; then
    . /etc/sysconfig/network
fi
if grep -q usbfs /proc/filesystems ; then
	mount -n -t usbfs /proc/bus/usb /proc/bus/usb
fi
 

if [ -z "$quiet" ] ; then
	# Print a text banner.
	echo -en $"\t\tWelcome to "
	[ "$BOOTUP" = "color" ] && echo -en "\\033[0;34m"
	echo -en "MeeGo"
	[ "$BOOTUP" = "color" ] && echo -en "\\033[0;39m"
	echo 
fi

# Fix console loglevel
if [ -n "$LOGLEVEL" ]; then
	/bin/dmesg -n $LOGLEVEL
fi

[ -x /sbin/boardname ] && /sbin/boardname > /dev/null 2>&1

touch /dev/.in_sysinit >/dev/null 2>&1

nice -n 20 /sbin/start_udev

mount -n /dev/pts >/dev/null 2>&1


# Configure kernel parameters
sysctl -e -p /etc/sysctl.conf >/dev/null 2>&1

# Set the hostname.
hostname ${HOSTNAME}


if [ -f /fsckoptions ]; then
	fsckoptions=`cat /fsckoptions`
fi

if [ -f /forcefsck ] || strstr "$cmdline" forcefsck ; then
	fsckoptions="-f $fsckoptions"
elif [ -f /.autofsck ]; then
	[ -f /etc/sysconfig/autofsck ] && . /etc/sysconfig/autofsck
	if [ "$AUTOFSCK_DEF_CHECK" = "yes" ]; then
		AUTOFSCK_OPT="$AUTOFSCK_OPT -f"
	fi
	if [ -n "$AUTOFSCK_SINGLEUSER" ]; then
		echo
		echo $"*** Warning -- the system did not shut down cleanly. "
		echo $"*** Dropping you to a shell; the system will continue"
		echo $"*** when you leave the shell."
		sulogin
	fi
	fsckoptions="$AUTOFSCK_OPT $fsckoptions"
fi

if [ "$BOOTUP" = "color" ]; then
	fsckoptions="-C $fsckoptions"
else
	fsckoptions="-V $fsckoptions"
fi

if ! [[ " $fsckoptions" =~ " -y" ]]; then
    	fsckoptions="-a $fsckoptions"
fi
if [ -f /fastboot ] || strstr "$cmdline" fastboot ; then
	fastboot="yes"
fi

if [ -z "$fastboot" ]; then
	STRING=$"Checking filesystems"
	ionice -t -c 1 -n 0 fsck -p -T -t noopts=_netdev -A $fsckoptions 
	rc=$?
	
	if [ "$rc" -eq "0" ]; then
		success "$STRING"
		echo
	elif [ "$rc" -eq "1" ]; then
	        passed "$STRING"
		echo
	elif [ "$rc" -eq "2" -o "$rc" -eq "3" ]; then 
		echo $"Unmounting file systems"
		umount -a
		mount -n -o remount,ro /
		echo $"Automatic reboot in progress."
		reboot -f
        fi
	
        # A return of 4 or higher means there were serious problems.
	if [ $rc -gt 1 ]; then
		# have to switch to the console!  
		[ -x /usr/bin/chvt ] && /usr/bin/chvt 1

		failure "$STRING"
		echo
		echo
		echo $"*** An error occurred during the file system check."
		echo $"*** Dropping you to a shell; the system will reboot"
		echo $"*** when you leave the shell."

                str=$"(Repair filesystem)"
		PS1="$str \# # "; export PS1
		sulogin

		echo $"Unmounting file systems"
		umount -a
		mount -n -o remount,ro /
		echo $"Automatic reboot in progress."
		reboot -f
	elif [ "$rc" -eq "1" ]; then
		_RUN_QUOTACHECK=1
	fi
fi

remount_needed() {
	local state oldifs
	state=`LC_ALL=C awk '/ \/ / && ($3 !~ /rootfs/) { print $4 }' /proc/mounts`
	oldifs=$IFS
	IFS=","
	for opt in $state ; do
		if [ "$opt" = "rw" ]; then
		IFS=$oldifs
		return 1
	fi
	done
	IFS=$oldifs
	return 0
}

# Remount the root filesystem read-write.
if remount_needed ; then
	ionice -t -c 1 -n 0 mount -n -o remount,rw /
fi

# Clear mtab
(> /etc/mtab) &> /dev/null

# Remove stale backups
rm -f /etc/mtab~ /etc/mtab~~

# Clean up various /tmp bits
rm -f /tmp/.X*-lock /tmp/.lock.* /tmp/.gdm_socket /tmp/.s.PGSQL.*
rm -rf /tmp/.X*-unix /tmp/.ICE-unix /tmp/.font-unix /tmp/hsperfdata_* \
	/tmp/kde-* /tmp/ksocket-* /tmp/mc-* /tmp/mcop-* /tmp/orbit-*  \
	/tmp/scrollkeeper-*  /tmp/ssh-*

# Enter mounted filesystems into /etc/mtab
mount -f /
mount -f /proc >/dev/null 2>&1
mount -f /sys >/dev/null 2>&1
mount -f /dev/pts >/dev/null 2>&1
mount -f /proc/bus/usb >/dev/null 2>&1

# /var/{lock,run}
mount -t tmpfs tmpfs /var/lock -o size=4m
mount -t tmpfs tmpfs /var/run -o size=4m
mkdir /var/run/console
mkdir -p /var/lock/subsys
mkdir -p /var/run/PolicyKit
chown root:polkituser /var/run/PolicyKit
chmod 0770 /var/run/PolicyKit

# Mount all other filesystems (except for NFS and /proc, which is already
# mounted). Contrary to standard usage,
# filesystems are NOT unmounted in single user mode.
mount -a -t nonfs,nfs4,smbfs,cifs -O no_netdev
mount -t debugfs none /sys/kernel/debug/


# Clean out /.
rm -f /fastboot /fsckoptions /forcefsck /.autofsck /halt /poweroff

# Clean up /var.
rm -rf /var/lock/cvs/* /var/run/screen/*
find -L /var/lock /var/run ! -type d -exec rm -f {} \;
rm -f /var/lib/rpm/__db* &> /dev/null
rm -f /var/gdm/.gdmfifo &> /dev/null

# start dbus
rm -f /var/run/messagebus.pid
mkdir -p /var/run/dbus
dbus-uuidgen --ensure
dbus-daemon --system --fork

touch /var/spool/gdm/force-display-on-active-vt
touch /var/spool/gdm/force-display-on-active-vt-2

# Make ICE directory
mkdir -m 1777 -p /tmp/.ICE-unix >/dev/null 2>&1
chown root:root /tmp/.ICE-unix

{
	# Clean up utmp/wtmp
	> /var/run/utmp
	> /var/run/utmpx
	touch /var/log/wtmp /var/log/wtmpx
	chgrp utmp /var/run/utmp{,x} /var/log/wtmp{,x}
	chmod 0664 /var/run/utmp{,x} /var/log/wtmp{,x}

	if [ -x "/usr/sbin/dsme" ] ; then
		export BOOTSTATE="USER"
		/usr/sbin/dsme -p /usr/lib/dsme/libstartup.so &>/dev/null &
	fi

	# wait for dbus to start accepting connections
	while ! dbus-send --system --reply-timeout=10 --dest=org.freedesktop.DBus /org/freedesktop/DBus/GetId org.freedesktop.DBus.GetId ; do : ; done
	# now we can start hal (yes, this is a hal/dbus bug)
	test -x /usr/sbin/hald && nice -n 20 hald --daemon=yes

	[ -x /usr/sbin/connmand ] && /usr/sbin/connmand -W nl80211,wext

	# when we're gathering readahead data, we want the background
	# startup to be later so that it ends up delayed in the
	# readahead as well.
	
	if [ ! -e /etc/readahead.packed ] ; then
		sleep 10
	fi

	# enable logging
	if [ -x /sbin/rsyslogd ] ; then
	(
		[ -f /etc/sysconfig/rsyslog ] && . /etc/sysconfig/rsyslog
		nice -n 20 /sbin/rsyslogd $SYSLOGD_OPTIONS
	)
	else
	(
		# Source config
		if [ -f /etc/sysconfig/sysklogd ] ; then
        		. /etc/sysconfig/sysklogd
		else
		        SYSLOGD_OPTIONS="-m 0"
        		KLOGD_OPTIONS="-2"
		fi

		if [ -z "$SYSLOG_UMASK" ] ; then
		      SYSLOG_UMASK=077;
		fi
		umask $SYSLOG_UMASK
		nice -n 20 /sbin/syslogd $SYSLOGD_OPTIONS
		nice -n 20 /sbin/klogd $KLOGD_OPTIONS
	)
	fi

	# start acpid for detecting the on/off key and such
	# must start before HAL.
	if [ -x /usr/sbin/acpid-start-script ] ; then
		/usr/sbin/acpid-start-script &
	fi

	# udevd -d

	rm -f /dev/.in_sysinit

	# restore saved random seed
	if [ -f "/var/lib/random-seed" ]; then
		cat /var/lib/random-seed > /dev/urandom
	else
		touch /var/lib/random-seed
		chmod 600 /var/lib/random-seed
	fi

	# Start up swapping for swap devices listed in /etc/fstab
	swapon -a -e
 
	# create the crash indicator flag to warn on crashes, offer fsck with timeout
	touch /.autofsck &> /dev/null

	# disable ALS - UX should enable it later on user choice
	( echo 0 > /sys/devices/platform/asus_laptop/als ) 2>&-

	# lots of heavy stuff started, the rest is background stuff that should come in later
	sleep 1

	# start avahi for zeroconf discovery
	cp -fp /etc/localtime /etc/avahi/etc >/dev/null 2>&1
	if [ -x /usr/sbin/avahi-daemon ] ; then
		/usr/sbin/avahi-daemon -D
	fi
	
	if [ -x "/usr/sbin/crond" ] ; then
		/usr/sbin/crond
	fi

	if [ -x "/usr/sbin/ofonod" ] ; then
		/usr/sbin/ofonod
	fi

	if [ -x "/usr/sbin/bluetoothd" ] ; then
		/usr/sbin/bluetoothd
	fi

	if [ -x "/usr/sbin/xinetd" ] ; then
		/usr/sbin/xinetd -stayalive
	fi
	
	if [ -x "/sbin/console_init" ] ; then
		/sbin/console_init /dev/tty0
	fi
	
	if [ -x "/usr/sbin/ohmd" ] ; then
		if [ -f "/etc/boardname" ]; then
			bn=`cat /etc/boardname`
			export OHM_CONF_PLATFORM=$bn
		fi
		/usr/sbin/ohmd
	fi

	if [ -x "/usr/sbin/sensord" ] ; then
		sensordconfig=""
		# Determine the correct "primary" config file: the first conf file
		# whose basename is a substring of boardname, if any (i.e. 'foo.conf'
		# matches all devices which have 'foo' in their /etc/boardname)
		if [ -f /etc/boardname ]; then
			for f in /etc/sensorfw/*conf; do
				fbase=`basename $f '.conf' | sed s/sensord-//`
				grep -q $fbase /etc/boardname
				if [ $? -eq 0 ]; then
					sensordconfig="-c=$f"
					break
				fi
			done
		fi
		/usr/sbin/sensord $sensordconfig -d --log-target=4 --log-file-path=/var/log/sensord.log
	fi

	if [ -x "/sbin/mce" ] ; then
		test -d /var/run/mce || (rm -f /var/run/mce; mkdir /var/run/mce)
		/sbin/mce -d --force-syslog
	fi
	
	if [ -x "/usr/bin/timed" ] ; then
		/usr/bin/timed &
	fi
	
	# enable SATA ALPM at the end of the disk sensitive part of the boot process
	sleep 5
	for lpm in /sys/class/scsi_host/host*/link_power_management_policy; do
		if [ -e $lpm ]; then
			echo "min_power" >$lpm
		fi
	done
} &

